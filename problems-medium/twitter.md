Designing Twitter requires building a microblogging platform that allows users to post short messages follow other users view personalized feeds engage through likes and retweets search content and discover trending topics at massive scale. Core requirements include users can post tweets up to 280 characters with optional media users can follow other users without mutual consent users see timeline of tweets from people they follow users can like retweet and reply to tweets support for hashtags and mentions search functionality for tweets and users trending topics based on popularity handling hundreds of millions of daily active users ensuring low latency for timeline generation and managing billions of tweets. The system architecture includes client applications web and mobile API gateway for routing tweet service for creating and storing tweets timeline service for generating user feeds user service for profiles and relationships search service for finding tweets and users trending service for identifying topics notification service for alerts media service for images and videos cache layer using Redis and databases with appropriate sharding. For tweet storage use a NoSQL database like Cassandra for high write throughput and horizontal scalability partition tweets by tweet_id store with schema like tweet_id user_id text created_at media_urls likes_count retweets_count and implement time-based partitioning for data lifecycle. User relationships graph requires storing followers and following using graph database or relational tables with follower_id following_id optimize for read-heavy fan-out operations denormalize for fast follower list retrieval and implement caching for celebrity accounts. Timeline generation approaches include fan-out on write where when user posts tweet push to all followers' timelines works well for users with moderate followers pre-compute timelines for fast reads but expensive for celebrities with millions of followers. Fan-out on read where generate timeline on-demand by querying tweets from followed users works for celebrity accounts fresh data guaranteed but slower read performance. Hybrid approach uses fan-out on write for most users and fan-out on read for celebrities with many followers combining both for optimal performance. Timeline storage uses Redis sorted sets with tweet_id as member and timestamp as score implement pagination for infinite scroll store limited number of recent tweets per user fall back to database for older tweets and implement cache warming for active users. The tweet creation flow involves user posting tweet through client tweet service validating content and generating unique tweet_id tweet service storing in database tweet service uploading media to media service if any timeline service performing fan-out to followers notification service alerting mentioned users and search service indexing tweet for search. For search functionality use Elasticsearch for full-text search index tweets in real-time support hashtag search user search and advanced filters rank results by relevance recency and engagement implement autocomplete for search suggestions and handle high query volume with read replicas. Trending topics detection involves analyzing hashtag usage frequency detecting sudden spikes in usage applying time-decay to recent trends filtering spam and bot activity regional trends based on geography and displaying personalized trends based on user interests. For scalability shard tweet database by tweet_id or user_id use read replicas for heavy read operations implement multi-level caching partition timeline service by user_id use message queues for async operations deploy across multiple data centers and implement rate limiting per user. The data model includes users table with user_id username email bio followers_count following_count tweets table with tweet_id user_id text timestamp media_urls follows table with follower_id following_id likes table with user_id tweet_id and retweets table with user_id original_tweet_id retweet_id. For engagement features implement atomic counters for likes and retweets handle double-click prevention use eventual consistency for counts show optimistic UI updates and sync with backend. Real-time features use WebSocket for live updates push notifications for mentions and replies implement activity streams show typing indicators in DMs and display live view counts. Additional features include direct messaging between users lists for organizing followed accounts verified accounts with blue checkmark moments for curating events polls and Twitter Spaces for audio analytics for tweet performance ads and promoted tweets and API for third-party integrations. For reliability implement redundancy at all layers use circuit breakers for service failures perform chaos engineering tests have disaster recovery plans monitor system health continuously and implement graceful degradation.
Data Replication involves maintaining multiple copies of data across different nodes for high availability, disaster recovery, and improved read performance, implemented through Master-Slave (primary-replica) replication where master handles all writes while replicas serve read traffic with asynchronous replication introducing replication lag where reads from replicas may see stale data but providing better write performance, or synchronous replication ensuring replicas have same data as master before commit completes guaranteeing consistency but increasing write latency, Master-Master (multi-master) replication allowing writes to multiple nodes enabling geographic distribution and avoiding single point of failure but requiring conflict resolution when concurrent updates occur on same record across masters using strategies like last-write-wins (based on timestamps), application-defined resolution, or operational transformation, implemented via Statement-based replication executing same SQL statements on replicas (compact but non-deterministic functions cause divergence), Row-based replication transferring actual changed data (more bandwidth but deterministic), or Change Data Capture (CDC) tracking and streaming database changes for real-time replication, with challenges including replication lag causing eventual consistency where replicas trail master by seconds to minutes requiring application handling of stale reads, failover complexity during master failure requiring promotion of replica to master with careful handling of uncommitted transactions and reconnecting clients, split-brain scenarios in multi-master setup where network partition causes multiple nodes thinking they're primary requiring quorum-based voting or external coordination, bandwidth and storage overhead from transferring and storing multiple copies, and consistency guarantees varying by topology where single-master provides strong consistency for writes but potentially stale reads, multi-master risks conflicts requiring resolution, and quorum reads/writes provide tunable consistency at cost of performance, commonly used patterns including read replicas for scaling read traffic, geographic replicas for disaster recovery and reduced latency serving users from nearest replica, and backup replicas for point-in-time recovery.

Database Architectures organize data and processing with Centralized Architecture using single database server handling all operations providing simplicity and strong consistency but creating single point of failure and scaling bottleneck, Replicated Architecture maintaining multiple database copies with master-slave or master-master configuration providing high availability and read scalability but introducing replication lag and complexity in failover, Sharded Architecture horizontally partitioning data across multiple independent databases based on shard key enabling unlimited scaling and parallelism but complicating cross-shard queries and transactions requiring careful key selection to avoid hotspots, Distributed SQL Architecture (NewSQL) combining traditional SQL semantics with distributed storage using consensus protocols like Raft or Paxos for strong consistency across nodes providing ACID guarantees at scale with transparent sharding and replication handling by database layer exemplified by Google Spanner and CockroachDB, Lambda Architecture separating batch and speed layers where batch layer processes complete dataset for accuracy and speed layer handles real-time updates for low latency with serving layer merging results allowing systems to balance throughput and latency but requiring maintaining two code paths, Kappa Architecture simplifying Lambda by using single stream processing path treating everything as infinite stream with reprocessing capabilities providing unified codebase but requiring stream processor to handle both real-time and batch workloads, Microservices Data Architecture where each service owns its database preventing tight coupling enabling independent scaling and technology choices but complicating cross-service queries and transactions requiring event-driven patterns or saga for distributed transactions with eventual consistency, CQRS (Command Query Responsibility Segregation) separating read and write models using different schemas optimized for their purpose with write model for updates and read model for queries allowing independent scaling and specialized storage but increasing complexity from maintaining multiple models and synchronization, and Data Lake Architecture storing raw data in cheap object storage (S3, Azure Blob) with processing engines (Spark, Presto) reading directly enabling flexible schema-on-read and diverse analytics but requiring careful data organization and governance to prevent becoming data swamp, with choice depending on consistency requirements, scale, access patterns, team expertise, and operational complexity tolerance.

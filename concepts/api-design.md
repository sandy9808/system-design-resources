API design involves creating interfaces that allow different software systems to communicate effectively. Good API design is crucial for developer experience scalability and long-term maintainability. REST Representational State Transfer is the most common API architecture using HTTP methods where GET retrieves resources POST creates new resources PUT updates entire resources PATCH updates partial resources and DELETE removes resources. RESTful APIs use resource-based URLs like /users/123/posts rather than action-based URLs follow stateless communication where each request contains all necessary information use standard HTTP status codes like 200 for success 201 for created 400 for bad request 404 for not found 500 for server error and return data typically in JSON format. GraphQL is an alternative to REST allowing clients to request exactly the data they need using a single endpoint with flexible queries reducing over-fetching and under-fetching enabling clients to specify nested data and providing strong typing with schema. API versioning strategies include URL versioning like /v1/users /v2/users which is explicit and easy to route header versioning using custom headers or Accept header which keeps URLs clean query parameter versioning like /users?version=1 which is flexible and content negotiation using media types. Rate limiting is essential to prevent abuse and ensure fair usage implementing token bucket or leaky bucket algorithms tracking usage per API key or user returning appropriate headers like X-RateLimit-Remaining and responding with 429 Too Many Requests when limit exceeded. Authentication mechanisms include API keys which are simple but less secure OAuth 2.0 which provides delegated access JWT tokens which are stateless and contain claims and mutual TLS for service-to-service communication. Idempotency ensures that making the same request multiple times has the same effect as making it once which is critical for reliability where GET PUT and DELETE are naturally idempotent POST is not idempotent by default and clients can send idempotency keys to make POST idempotent. Pagination is necessary for large datasets using offset-based pagination with limit and offset parameters cursor-based pagination using opaque cursors for consistent results or page-based pagination with page numbers. Error handling should provide clear error messages with error codes use consistent error response format include helpful details for debugging avoid exposing sensitive information and provide error documentation. API documentation is critical using OpenAPI Swagger specification providing interactive API explorers including code examples maintaining up-to-date docs and versioning documentation with API. Best practices include using nouns for resources not verbs using plural names for collections keeping URLs simple and intuitive using HTTP methods correctly providing filtering sorting and searching supporting compression with gzip implementing CORS for web clients using HTTPS for all endpoints designing for backward compatibility monitoring API usage and performance and deprecating old versions gracefully.
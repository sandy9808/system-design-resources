Database indexing is a technique to optimize query performance by creating data structures that allow fast data retrieval without scanning entire tables. An index is like a book's index that helps you quickly find pages containing specific topics rather than reading the entire book. Without indexes queries require full table scans examining every row which becomes extremely slow as tables grow. Primary indexes are automatically created on primary key columns ensuring uniqueness and providing fast lookups. Secondary indexes are created on non-primary key columns to speed up queries on those columns but they come with storage overhead and slower write operations since indexes must be updated on every insert update or delete. Types of indexes include B-tree indexes which are the most common default type working well for equality and range queries maintaining sorted order and supporting efficient insertions and deletions Hash indexes which use hash tables for exact match queries providing O(1) lookup time but not supporting range queries Bitmap indexes which are efficient for columns with low cardinality like gender or status using bitmaps to represent presence or absence and Full-text indexes which are specialized for text search supporting word matching and relevance ranking. Composite indexes are built on multiple columns useful when queries filter or sort by multiple columns where column order matters as queries can use the index if they match the leftmost columns. Covering indexes include all columns needed by a query allowing the database to satisfy the query entirely from the index without accessing the table data reducing I/O operations. Clustered indexes determine the physical order of data in the table where the table data is stored in the order of the clustered index typically the primary key and each table can have only one clustered index. Non-clustered indexes maintain a separate structure from the table data with pointers back to table rows and tables can have multiple non-clustered indexes. Index selection strategy involves analyzing query patterns identifying frequently filtered sorted or joined columns considering cardinality where high cardinality columns benefit more from indexes avoiding over-indexing as each index adds overhead monitoring index usage to identify unused indexes and using database query planners to understand execution plans. Partial indexes cover only a subset of table rows useful when queries consistently filter on specific conditions saving storage space and improving write performance. Expression indexes are built on computed expressions rather than column values useful for queries that filter on transformed data. Write performance impact is significant as every insert update or delete requires updating all relevant indexes adding latency and I/O overhead making it a tradeoff between read and write performance. Index maintenance involves periodic rebuilding to reduce fragmentation updating statistics for query optimizer regular monitoring of index usage considering partitioning for very large indexes and balancing number of indexes with write performance needs. Best practices include creating indexes on foreign key columns indexing columns used in WHERE clauses indexing columns used in JOIN conditions using composite indexes for multi-column queries avoiding indexes on frequently updated columns monitoring query performance regularly analyzing slow query logs using EXPLAIN to understand query plans and removing unused indexes to reduce overhead.
Service Discovery enables microservices to locate and communicate with each other in dynamic environments where service instances frequently change due to scaling, deployment, or failures, implemented through Client-Side Discovery where client queries service registry (like Consul, Eureka, Etcd) to get available instances and implements load balancing logic providing flexibility and reducing latency but requiring client library integration and handling of stale data, or Server-Side Discovery where client makes requests to load balancer or API gateway that queries registry and routes traffic simplifying clients but creating potential single point of failure and additional hop, using Service Registry as centralized database storing service locations with health checks and registration/deregistration APIs requiring strong consistency for accurate routing and high availability to prevent system-wide failures, registration patterns including Self-Registration where services register themselves on startup and deregister on shutdown providing autonomy but requiring registration logic in each service, or Third-Party Registration where separate registration service (like Registrator, Kubernetes) monitors services and manages registry reducing service complexity but requiring infrastructure components, supporting DNS-Based Discovery using DNS SRV records providing universal compatibility but limited health checking and slower propagation of changes, Key-Value Store Discovery maintaining service information in distributed stores like Consul or Etcd offering strong consistency and watch capabilities for real-time updates, or Platform-Integrated Discovery like Kubernetes with built-in service discovery through DNS and environment variables simplifying configuration within cluster, implementing Health Checking through periodic health endpoint polling, heartbeat mechanisms, or passive monitoring of traffic failures to remove unhealthy instances from pool, Load Balancing strategies including round-robin, least connections, random selection, consistent hashing for session affinity, and geographic proximity routing, and Service Metadata tagging instances with version, data center, capabilities enabling advanced routing like canary deployments and blue-green deployments, challenges including Registry Availability requiring distributed registry with replication to avoid single point of failure, Consistency vs Availability trade-offs where stale registry data causes failed requests but strong consistency reduces availability during partitions, Network Overhead from frequent registry queries solved by caching with TTL, and Cross-Datacenter discovery coordinating services across regions with local registries and federation.

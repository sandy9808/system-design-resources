Distributed Locking coordinates access to shared resources across multiple nodes preventing race conditions and ensuring mutual exclusion in distributed systems, implemented through Database-Based Locks using unique constraints or compare-and-swap operations where lock acquired by inserting row with resource identifier, held while row exists, and released by deleting row providing durability and ACID guarantees but adding database load and potential bottlenecks with lock holder failures requiring timeouts or separate cleanup processes, Cache-Based Locks using Redis or Memcached with SET NX (set if not exists) and expiration time providing low latency and automatic timeout handling through TTL but risking lock loss if cache evicts entry or expires prematurely leading to dual ownership, Redis implementing Redlock algorithm requiring majority of independent Redis masters to acquire lock providing better reliability than single instance by using odd number of independent Redis instances (typically 5), client acquiring locks sequentially using same key and TTL on all instances with random value, considering lock acquired if majority succeeds within validity time accounting for clock drift, releasing by deleting key on all instances, addressing issues like GC pauses causing holder to pause while lock expires allowing another client to acquire, Coordination Services like Zookeeper or etcd using ephemeral nodes that exist only during client session where lock acquired by creating ephemeral sequential node, lowest sequence number holds lock, other clients watch predecessor node waiting for deletion, lock automatically released when session ends or client crashes providing reliable failure detection but adding latency from consensus protocol, Lease-Based Locking extending locks with time-limited leases requiring periodic renewal by holder, automatically expiring if not renewed allowing recovery from failures without deadlocks, implemented with fencing tokens providing monotonically increasing numbers with lock acquisition, resource checking token and rejecting operations with old tokens preventing zombie lock holders from corrupting state after lease expired, used for Leader Election ensuring single leader coordinates work, Critical Sections protecting non-idempotent operations like inventory decrement, Distributed Cron preventing multiple instances from running same scheduled job, and Resource Allocation managing limited resources like database connections or API quotas, with patterns including Try-Lock attempting acquisition without blocking returning immediately if unavailable, Lock with Timeout attempting for limited time before giving up preventing infinite waiting, and Reentrant Locks allowing same holder to acquire multiple times with release count matching acquisition count, challenges include Deadlock where circular wait occurs requiring detection and prevention strategies like timeouts or lock ordering, Split-Brain scenarios during network partitions possibly creating multiple lock holders addressed by quorum requirements or fencing, Clock Drift causing lease expiration mismatches requiring clock synchronization or conservative TTL, and Performance overhead from coordination messages and persistence trading availability and consistency for mutual exclusion, with modern alternatives like optimistic locking using version numbers avoiding locks entirely by detecting conflicts at commit time, and deterministic ordering processing requests in agreed sequence eliminating need for locks through consensus.
